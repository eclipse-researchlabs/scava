{
  "recommendationItems": [
    {
      "apiDocumentationLink": null,
      "apiCallRecommendation": null,
      "significance": 0,
      "recommendationType": null,
      "apiFunctionCallFOCUS": null,
      "codeSnippet": "protected void launch(String[] args) throws ParseException, IOException,\n\t\t\tClassNotFoundException, InstantiationException,\n\t\t\tIllegalAccessException, IllegalArgumentException,\n\t\t\tInvocationTargetException {\n\t\tOptions options = new Options();\n\t\toptions.addOption(OptionBuilder.withArgName(COMMAND_LABEL).hasArg()\n\t\t\t\t.withDescription(\"command to be launched\")\n\t\t\t\t.create(COMMAND_LABEL));\n\t\toptions.addOption(OptionBuilder.withArgName(HELP_LABEL)\n\t\t\t\t.withDescription(\"print this help\").create(HELP_LABEL));\n\t\tSet<LaunchConfiguration> launchConfigurations = ar\n\t\t\t\t.getLaunchConfiguration();\n\t\tLaunchConfiguration launchConfiguration = launchConfigurations\n\t\t\t\t.iterator().next();\n\t\toptionBuilder.buildOptions(options, launchConfiguration);\n\t\tCommandLineParser parser = new GnuParser();\n\t\tCommandLine line = parser.parse(options, args);\n\t\tif (!line.hasOption(HELP_LABEL)\n\t\t\t\t&& optionBuilder.initAndValidate(launchConfiguration, line)) {\n\t\t\tString cmd = Launcher.DEFAULT_COMMAND;\n\t\t\tif (line.hasOption(COMMAND_LABEL)) {\n\t\t\t\tcmd = line.getOptionValue(COMMAND_LABEL);\n\t\t\t}\n\t\t\tlaunchConfiguration.run(cmd);\n\t\t} else {\n\t\t\tprintHelp(options);\n\t\t}\n\t}"
    },
    {
      "apiDocumentationLink": null,
      "apiCallRecommendation": null,
      "significance": 0,
      "recommendationType": null,
      "apiFunctionCallFOCUS": null,
      "codeSnippet": "public static void main(String[] args) {\n        Main main = new Main();\n\n        main.header(\"Liquibase SDK\");\n\n        try {\n            main.init(args);\n\n            if (main.command == null) {\n                throw new UserError(\"No command passed\");\n            }\n\n            if (main.command.equals(\"help\")) {\n                main.printHelp();\n                return;\n            }\n\n            LiquibaseCommand command;\n            CommandLineParser commandParser = new GnuParser();\n            if (main.command.equals(\"convert\")) {\n                command = new ConvertCommand(main);\n\n                Options options = new Options();\n                options.addOption(OptionBuilder.hasArg().withDescription(\"Original changelog\").isRequired().create(\"src\"));\n                options.addOption(OptionBuilder.hasArg().withDescription(\"Output changelog\").isRequired().create(\"out\"));\n                options.addOption(OptionBuilder.hasArg().withDescription(\"Classpath\").create(\"classpath\"));\n\n                CommandLine commandArguments = commandParser.parse(options, main.commandArgs.toArray(new String[main.commandArgs.size()]));\n                ((ConvertCommand) command).setSrc(commandArguments.getOptionValue(\"src\"));\n                ((ConvertCommand) command).setOut(commandArguments.getOptionValue(\"out\"));\n                ((ConvertCommand) command).setClasspath(commandArguments.getOptionValue(\"classpath\"));\n            } else {\n                throw new UserError(\"Unknown command: \"+main.command);\n            }\n\n            command.execute();\n\n            main.divider();\n            main.out(\"Command executed successfully\");\n\n\n        } catch (UserError userError) {\n            main.out(\"\");\n            main.header(\"ERROR EXECUTING COMMAND\");\n            main.out(userError.getMessage());\n            main.out(\"\");\n            main.out(\"\");\n            return;\n        } catch (Throwable exception) {\n            System.out.println(\"Unexpected error: \"+exception.getMessage());\n            exception.printStackTrace();\n        }\n    }"
    },
    {
      "apiDocumentationLink": null,
      "apiCallRecommendation": null,
      "significance": 0,
      "recommendationType": null,
      "apiFunctionCallFOCUS": null,
      "codeSnippet": "public File[] parseCommandLine(String[] args) throws ParseException {\n        final Option fileOpt = new Option(\"f\", \"file\", true, \"A single chanpub file to publish.\");\n        final Option dirOpt = new Option(\"d\", \"dir\", true, \"A directory of chanpub files to publish. (all .xml files in the directory will be processed)\");\n\n        final OptionGroup optGroup = new OptionGroup();\n        optGroup.addOption(fileOpt);\n        optGroup.addOption(dirOpt);\n        optGroup.setRequired(true);\n\n        final Options options = new Options();\n        options.addOptionGroup(optGroup);\n\n        final CommandLineParser parser = new GnuParser();\n        final CommandLine line;\n        try {\n            // parse the command line arguments\n            line = parser.parse(options, args);\n        }\n        catch (ParseException exp) {\n            final HelpFormatter formatter = new HelpFormatter();\n            formatter.printHelp(120, \"java \" + this.getClass().getName(), \"\", options, \"\", true);\n            throw exp;\n        }\n        \n        final File[] files;\n        if (line.hasOption(fileOpt.getOpt())) {\n            final String chanPubName = line.getOptionValue(fileOpt.getOpt());\n            final File chanPubFile = new File(chanPubName);\n            files = new File[] { chanPubFile };\n        }\n        else if (line.hasOption(dirOpt.getOpt())) {\n            final String chanPubDirName = line.getOptionValue(dirOpt.getOpt());\n            final File chanPubDir = new File(chanPubDirName);\n            \n            if (!chanPubDir.exists()) {\n                throw new IllegalArgumentException(\"Directory '\" + chanPubDir + \"' does not exist.\");\n            }\n            \n            files = chanPubDir.listFiles(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    return name.endsWith(\".xml\");\n                }\n            });\n        }\n        else {\n            throw new IllegalStateException(\"Should not be possible\");\n        }\n        \n        return files;\n    }"
    },
    {
      "apiDocumentationLink": null,
      "apiCallRecommendation": null,
      "significance": 0,
      "recommendationType": null,
      "apiFunctionCallFOCUS": null,
      "codeSnippet": "private void parseCmdLine (String[] args) {\n        CommandLineParser parser = new PosixParser ();\n\n        Options options = new Options ();\n        options.addOption (\"v\",\"version\", false, \"Q2's version\");\n        options.addOption (\"d\",\"deploydir\", true, \"Deployment directory\");\n        options.addOption (\"r\",\"recursive\", false, \"Deploy subdirectories recursively\");\n        options.addOption (\"h\",\"help\", false, \"Usage information\");\n        options.addOption (\"C\",\"config\", true, \"Configuration bundle\");\n        options.addOption (\"e\",\"encrypt\", true, \"Encrypt configuration bundle\");\n        options.addOption (\"i\",\"cli\", false, \"Command Line Interface\");\n        options.addOption (\"c\",\"command\", true, \"Command to execute\");\n        options.addOption (\"O\", \"osgi\", false, \"Start experimental OSGi framework server\");\n\n        try {\n            CommandLine line = parser.parse (options, args);\n            if (line.hasOption (\"v\")) {\n                displayVersion();\n                System.exit (0);\n            } \n            if (line.hasOption (\"h\")) {\n                HelpFormatter helpFormatter = new HelpFormatter ();\n                helpFormatter.printHelp (\"Q2\", options);\n                System.exit (0);\n            } \n            if (line.hasOption (\"c\")) {\n                cli = new CLI(this, line.getOptionValue(\"c\"), line.hasOption(\"i\"));\n            } else if (line.hasOption (\"i\")) \n                cli = new CLI(this, null, true);\n\n            String dir = DEFAULT_DEPLOY_DIR;\n            if (line.hasOption (\"d\")) {\n                dir = line.getOptionValue (\"d\");\n            }\n            recursive = line.hasOption (\"r\");\n            this.deployDir  = new File (dir);\n            if (line.hasOption (\"C\"))\n                deployBundle (new File (line.getOptionValue (\"C\")), false);\n            if (line.hasOption (\"e\"))\n                deployBundle (new File (line.getOptionValue (\"e\")), true);\n            if (line.hasOption(\"O\"))\n                startOSGI = true;\n        } catch (MissingArgumentException e) {\n            System.out.println(\"ERROR: \" + e.getMessage());\n            System.exit(1);\n        } catch (IllegalAccessError e) {\n            System.out.println(e.getMessage());\n            System.exit(1);\n        } catch (Exception e) {\n            e.printStackTrace ();\n            System.exit (1);\n        }\n    }"
    },
    {
      "apiDocumentationLink": null,
      "apiCallRecommendation": null,
      "significance": 0,
      "recommendationType": null,
      "apiFunctionCallFOCUS": null,
      "codeSnippet": "/**\r\n\t * Simple command line interface to read an XML DTD file and create\r\n\t * corresponding XML Schema file. Usage:\r\n\t * \r\n\t * <pre>\r\n\t * java org.exolab.castor.xml.dtd.Converter  dtd_file xsd_file [character_encoding]\r\n\t *    [-tns=[TNS_PREFIX:]NAMESPACE_URI]\r\n\t *    [-xmlns=[TNS_PREFIX:]NAMESPACE_URI]*\r\n\t * \r\n\t * dtd_file: name of the input DTD file\r\n\t * xsd_file: name of the output Schema file\r\n\t * character_encoding: name of the character encoding,\r\n\t *            if not specified, ASCII is chosen\r\n\t * </pre>\r\n\t * \r\n\t * Help message is provided.\r\n\t * \r\n\t * @throws DTDException\r\n\t *             if the input DTD document is malformed.\r\n\t * @throws SchemaException\r\n\t *             if Schema object can not be created.\r\n\t * @throws SAXException\r\n\t *             if an error occured during marshalling of schema object\r\n\t *             constructed from the DTD document.\r\n\t */\r\n\tpublic static void main(String args[]) throws IOException, DTDException,\r\n\t\t\tSchemaException, SAXException {\r\n\t\t\r\n\t\tStringBuffer header = new StringBuffer();\r\n\t\theader.append(\"\\n\");\r\n\t\theader.append(\"Converts a DTD to an XML schema.\\n\\n\");\r\n\t\theader.append(\"   <DTD>: Name of the input DTD file.\\n\");\r\n\t\theader.append(\"   <XSD>: Name of the output XML schema file.\\n\");\r\n\t\theader.append(\"\\n\");\r\n\t\theader.append(\"Options:\");\r\n\t\t\r\n\t\tOptions options = new Options();\r\n\t\t\r\n\t\tOption targetNamespace = OptionBuilder\r\n\t\t\t.withDescription(\"target namespace of the XML schema generated\")\r\n\t\t\t.isRequired(false)\r\n\t\t\t.withLongOpt(\"targetNamespace\")\r\n\t\t\t.hasArg()\r\n\t\t\t.withArgName(\"[prefix:]uri\")\r\n\t\t\t.create(\"tns\");\r\n\r\n\t\tOption xmlns = OptionBuilder\r\n\t\t.withDescription(\"xml namespace declarations\")\r\n\t\t.isRequired(false)\r\n\t\t.hasArgs()\r\n\t\t.withValueSeparator(',')\r\n\t\t.withArgName(\"[[prefix:]uri]*\")\r\n\t\t.create(\"xmlns\");\r\n\r\n\t\toptions.addOption(targetNamespace);\r\n\t\toptions.addOption(xmlns);\r\n\t\toptions.addOption(\"h\", \"help\", false, \"prints usage information\");\r\n\t\toptions.addOption(\"e\", \"encoding\", false, \"character encoding\");\r\n\t\t\r\n\t\tCommandLineParser parser = new GnuParser();\r\n\t\tCommandLine line = null;\r\n\t    try {\r\n\t\t\tline = parser.parse(options, args);\r\n\t    } catch (org.apache.commons.cli.ParseException e) {\r\n\t    \tSystem.err.println( \"Parsing failed.  Reason: \" + e.getMessage() );\r\n\t\t}\r\n\r\n\t\tif (args.length < 2 || line.hasOption(\"help\")) {\r\n\t\t\tHelpFormatter formatter = new HelpFormatter();\r\n\t\t\tformatter.printHelp(\"org.exolab.castor.xml.dtd.Converter <DTD> <XSD>\", \r\n\t\t\t\t\theader.toString(),\r\n\t\t\t\t\toptions,\r\n\t\t\t\t\t\"\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tString encoding = \"US-ASCII\";\r\n\t\tString targetNameSpace = DEFAULT_NAME_SPACE;\r\n\t\tMap<String, String> nameSpaceMap = new HashMap<String, String>();\r\n\r\n\t\tif (line.hasOption(\"tns\")) {\r\n\t\t\tlog.info(\"Found option -tns ...\");\r\n\t\t\tMap<String, String> nameSpaceMapTemp = parseNamespace(line.getOptionValue(\"tns\"));\r\n\t\t\ttargetNameSpace = nameSpaceMapTemp.get(NAME_SPACE_KEY);\r\n\t\t\tnameSpaceMap.put(nameSpaceMapTemp.get(NAME_SPACE_PREFIX_KEY), targetNameSpace);\r\n\t\t}\r\n\r\n\t\tif (line.hasOption(\"xmlns\")) {\r\n\t\t\tlog.info(\"Found option -xmlns ...\");\r\n\t\t\tMap<String, String> nameSpaceMapTemp = parseNamespace(line.getOptionValue(\"xmlns\"));\r\n\t\t\tnameSpaceMap.put(nameSpaceMapTemp.get(NAME_SPACE_PREFIX_KEY), \r\n\t\t\t\t\tnameSpaceMapTemp.get(NAME_SPACE_KEY));\r\n\t\t}\r\n\r\n\t\tif (line.hasOption(\"encoding\")) {\r\n\t\t\tlog.info(\"Found option -encoding ...\");\r\n\t\t\tString encodingValue = line.getOptionValue(\"encoding\");\r\n\t\t\tif (encodingValue.equalsIgnoreCase(\"ascii\")\r\n\t\t\t\t\t|| args[2].equalsIgnoreCase(\"us-ascii\")) {\r\n\t\t\t\tencoding = \"US-ASCII\";\r\n\t\t\t} else if (encodingValue.equalsIgnoreCase(\"utf-8\")) {\r\n\t\t\t\tencoding = \"UTF-8\";\r\n\t\t\t} else if (encodingValue.equalsIgnoreCase(\"utf-16\")) {\r\n\t\t\t\tencoding = \"UTF-16\";\r\n\t\t\t} else {\r\n\t\t\t\tencoding = encodingValue.toUpperCase();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tString inFile = args[0];\r\n\t\tString outFile = args[1];\r\n\r\n\t\tConverter convertor = new Converter();\r\n\t\tconvertor.process(inFile, outFile, encoding, targetNameSpace, nameSpaceMap);\r\n\t}"
    },
    {
      "apiDocumentationLink": null,
      "apiCallRecommendation": null,
      "significance": 0,
      "recommendationType": null,
      "apiFunctionCallFOCUS": null,
      "codeSnippet": "/**\n\t * Builds a list of legal options and store them into the options objects.\n\t */\n\t@SuppressWarnings(\"static-access\")\n\tprivate static void initOptions() {\n\n\t\tList<String> actions = new ArrayList<>(KNOWN_ACTIONS.keySet());\n\t\tCollections.sort(actions);\n\t\tOption action = OptionBuilder\n\t\t\t\t.hasArg()\n\t\t\t\t.withArgName(\"action\")\n\t\t\t\t.withDescription(\n\t\t\t\t\t\t\"define the action that should be performed; avaible actions: \"\n\t\t\t\t\t\t\t\t+ actions).withLongOpt(OPTION_ACTION)\n\t\t\t\t.create(CMD_OPTION_ACTION);\n\n\t\tOption destination = OptionBuilder.withArgName(\"path\").hasArg()\n\t\t\t\t.withDescription(\"place the output into the file at <path>\")\n\t\t\t\t.withLongOpt(OPTION_OUTPUT_DESTINATION)\n\t\t\t\t.create(CMD_OPTION_OUTPUT_DESTINATION);\n\n\t\tOption dumplocation = OptionBuilder\n\t\t\t\t.hasArg()\n\t\t\t\t.withArgName(\"path\")\n\t\t\t\t.withDescription(\n\t\t\t\t\t\t\"set the directory where downloaded dump files are stored\")\n\t\t\t\t.withLongOpt(OPTION_DUMP_LOCATION)\n\t\t\t\t.create(CMD_OPTION_DUMP_LOCATION);\n\n\t\tOption config = OptionBuilder\n\t\t\t\t.hasArg()\n\t\t\t\t.withArgName(\"file\")\n\t\t\t\t.withDescription(\n\t\t\t\t\t\t\"set a config file; use this to define multiple actions for a single run\")\n\t\t\t\t.withLongOpt(OPTION_CONFIG_FILE).create(CMD_OPTION_CONFIG_FILE);\n\n\t\tOption rdfdump = OptionBuilder\n\t\t\t\t.hasArgs()\n\t\t\t\t.withArgName(\"task\")\n\t\t\t\t.withDescription(\n\t\t\t\t\t\t\"specify which data to include in RDF dump (use with action \\\"rdf\\\"); run with options \\\"-a rdf -n\\\" for help\")\n\t\t\t\t.withLongOpt(OPTION_OUTPUT_RDF_TYPE).create();\n\n\t\tOption filterLanguages = OptionBuilder\n\t\t\t\t.hasArgs()\n\t\t\t\t.withArgName(\"languages\")\n\t\t\t\t.withDescription(\n\t\t\t\t\t\t\"specifies a list of language codes; if given, only terms in languages in this list will be processed; the value \\\"-\\\" denotes the empty list (no terms are processed)\")\n\t\t\t\t.withLongOpt(OPTION_FILTER_LANGUAGES).create();\n\n\t\tOption filterSites = OptionBuilder\n\t\t\t\t.hasArgs()\n\t\t\t\t.withArgName(\"sites\")\n\t\t\t\t.withDescription(\n\t\t\t\t\t\t\"specifies a list of site keys; if given, only site links to sites in this list will be processed; the value \\\"-\\\" denotes the empty list (no site links are processed)\")\n\t\t\t\t.withLongOpt(OPTION_FILTER_SITES).create();\n\n\t\tOption filterProperties = OptionBuilder\n\t\t\t\t.hasArgs()\n\t\t\t\t.withArgName(\"ids\")\n\t\t\t\t.withDescription(\n\t\t\t\t\t\t\"specifies a list of property ids; if given, only statements for properties in this list will be processed; the value \\\"-\\\" denotes the empty list (no statements are processed)\")\n\t\t\t\t.withLongOpt(OPTION_FILTER_PROPERTIES).create();\n\n\t\tOption compressionExtention = OptionBuilder\n\t\t\t\t.hasArg()\n\t\t\t\t.withArgName(\"type\")\n\t\t\t\t.withDescription(\n\t\t\t\t\t\t\"define a compression format to be used for the output; possible values: \"\n\t\t\t\t\t\t\t\t+ DumpProcessingOutputAction.COMPRESS_GZIP\n\t\t\t\t\t\t\t\t+ \", \"\n\t\t\t\t\t\t\t\t+ DumpProcessingOutputAction.COMPRESS_BZ2)\n\t\t\t\t.withLongOpt(OPTION_OUTPUT_COMPRESSION)\n\t\t\t\t.create(CMD_OPTION_OUTPUT_COMPRESSION);\n\n\t\tOption report = OptionBuilder\n\t\t\t\t.hasArg()\n\t\t\t\t.withArgName(\"path\")\n\t\t\t\t.withDescription(\n\t\t\t\t\t\t\"specifies a path to print a final report after dump generations\")\n\t\t\t\t.withLongOpt(OPTION_CREATE_REPORT)\n\t\t\t\t.create(CMD_OPTION_CREATE_REPORT);\n\n\t\tOption localDump = OptionBuilder\n\t\t\t\t.hasArg()\n\t\t\t\t.withArgName(\"path\")\n\t\t\t\t.withDescription(\n\t\t\t\t\t\t\"select a dump file for processing; if omitted, then the latest dump from Wikidata will be used (and possibly downloaded)\")\n\t\t\t\t.withLongOpt(OPTION_LOCAL_DUMPFILE)\n\t\t\t\t.create(CMD_OPTION_LOCAL_DUMPFILE);\n\n\t\toptions.addOption(config);\n\t\toptions.addOption(action);\n\t\toptions.addOption(\n\t\t\t\tCMD_OPTION_QUIET,\n\t\t\t\tOPTION_QUIET,\n\t\t\t\tfalse,\n\t\t\t\t\"perform all actions quietly, without printing status messages to the console; errors/warnings are still printed to stderr\");\n\t\toptions.addOption(destination);\n\t\toptions.addOption(dumplocation);\n\t\toptions.addOption(filterLanguages);\n\t\toptions.addOption(filterSites);\n\t\toptions.addOption(filterProperties);\n\t\toptions.addOption(compressionExtention);\n\t\toptions.addOption(report);\n\t\toptions.addOption(localDump);\n\t\toptions.addOption(rdfdump);\n\t\toptions.addOption(CMD_OPTION_OFFLINE_MODE, OPTION_OFFLINE_MODE, false,\n\t\t\t\t\"execute all operations in offline mode, especially do not download new dumps\");\n\t\toptions.addOption(CMD_OPTION_HELP, OPTION_HELP, false,\n\t\t\t\t\"print this message\");\n\n\t\toptions.addOption(CMD_OPTION_OUTPUT_STDOUT, OPTION_OUTPUT_STDOUT,\n\t\t\t\tfalse, \"write output to stdout\");\n\t}"
    },
    {
      "apiDocumentationLink": null,
      "apiCallRecommendation": null,
      "significance": 0,
      "recommendationType": null,
      "apiFunctionCallFOCUS": null,
      "codeSnippet": "/**\n     * When invoked as a command-line tool, creates, updates, removes\n     * content from the whole index\n     *\n     * @param args\n     *            the command-line arguments, none used\n     * @throws IOException\n     * @throws SQLException\n     */\n    public static void main(String[] args) throws SQLException, IOException\n    {\n        Date startTime = new Date();\n        try\n        {\n            setBatchProcessingMode(true);\n            Context context = new Context();\n            context.turnOffAuthorisationSystem();\n\n            String usage = \"org.dspace.search.DSIndexer [-cbhof[r <item handle>]] or nothing to update/clean an existing index.\";\n            Options options = new Options();\n            HelpFormatter formatter = new HelpFormatter();\n            CommandLine line = null;\n\n            options.addOption(OptionBuilder\n                            .withArgName(\"item handle\")\n                            .hasArg(true)\n                            .withDescription(\n                                    \"remove an Item, Collection or Community from index based on its handle\")\n                            .create(\"r\"));\n\n            options.addOption(OptionBuilder.isRequired(false).withDescription(\n                    \"optimize existing index\").create(\"o\"));\n\n            options.addOption(OptionBuilder\n                            .isRequired(false)\n                            .withDescription(\n                                    \"clean existing index removing any documents that no longer exist in the db\")\n                            .create(\"c\"));\n\n            options.addOption(OptionBuilder.isRequired(false).withDescription(\n                    \"(re)build index, wiping out current one if it exists\").create(\n                    \"b\"));\n\n            options.addOption(OptionBuilder\n                            .isRequired(false)\n                            .withDescription(\n                                    \"if updating existing index, force each handle to be reindexed even if uptodate\")\n                            .create(\"f\"));\n\n            options.addOption(OptionBuilder.isRequired(false).withDescription(\n                    \"print this help message\").create(\"h\"));\n\n            try\n            {\n                line = new PosixParser().parse(options, args);\n            }\n            catch (Exception e)\n            {\n                // automatically generate the help statement\n                formatter.printHelp(usage, e.getMessage(), options, \"\");\n                System.exit(1);\n            }\n\n            if (line.hasOption(\"h\"))\n            {\n                // automatically generate the help statement\n                formatter.printHelp(usage, options);\n                System.exit(1);\n            }\n\n            if (line.hasOption(\"r\"))\n            {\n                log.info(\"Removing \" + line.getOptionValue(\"r\") + \" from Index\");\n                unIndexContent(context, line.getOptionValue(\"r\"));\n            }\n            else if (line.hasOption(\"o\"))\n            {\n                log.info(\"Optimizing Index\");\n                optimizeIndex(context);\n            }\n            else if (line.hasOption(\"c\"))\n            {\n                log.info(\"Cleaning Index\");\n                cleanIndex(context);\n            }\n            else if (line.hasOption(\"b\"))\n            {\n                log.info(\"(Re)building index from scratch.\");\n                createIndex(context);\n            }\n            else\n            {\n                log.info(\"Updating and Cleaning Index\");\n                cleanIndex(context);\n                updateIndex(context, line.hasOption(\"f\"));\n            }\n\n            log.info(\"Done with indexing\");\n        }\n        finally\n        {\n            setBatchProcessingMode(false);\n            Date endTime = new Date();\n            System.out.println(\"Started: \" + startTime.getTime());\n            System.out.println(\"Ended: \" + endTime.getTime());\n            System.out.println(\"Elapsed time: \" + ((endTime.getTime() - startTime.getTime()) / 1000) + \" secs (\" + (endTime.getTime() - startTime.getTime()) + \" msecs)\");\n        }\n    }"
    }
  ]
}