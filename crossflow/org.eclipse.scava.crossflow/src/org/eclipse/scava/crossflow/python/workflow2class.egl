[%import "../util.eol";
import "pythonUtil.eol";%]
import argparse
import sys
import time

# Tasks
[%for (t in w.getPyTasks()) {%]
from [%=package%].[%=t.pyVarName()%] import [%=t.name%]
[%}%]

# Types
[% for (t in CrossflowLanguageModel!Type.all) {%]
from crossflow.[%=package%] import [%=t.name.toSnakeCaseLower()%]
[%}%]

# Streams
[%for (s in w.streams) {
	if(not s.inputOf.isEmpty()) {%]
from crossflow.[%=package%].[%=s.pyVarName()%] import [%=s.name%]
[%	}
}%]

# Utility
from crossflow.[%=package%].[%=w.pyVarName()%]_tasks import [%=w.name%]Tasks
from crossflow.runtime import BuiltinStream, Mode, Workflow
from crossflow.serialization import Serializer, JsonSerializer


class [%=w.name%](Workflow):
    """NOTE: Auto-generated by [%=genRule%][%if (genDate.isDefined()) {%] on [%=genDate%][%}%]
    
    Do not edit this class manually
    """

    def __init__(
        self,
        name="",
        instance=None,
        broker_host="localhost",
        stomp_port=61613,
        mode=Mode.WORKER,
        cache=None,
        cache_enabled=True,
        delete_cache=None,
        excluded_tasks=None,
        enable_prefetch=False
    ):
                 
        super().__init__(name=name,
                         instance=instance,
                         broker_host=broker_host,
                         stomp_port=stomp_port,
                         mode=mode,
                         cache=cache,
                         cache_enabled=cache_enabled,
                         delete_cache=delete_cache,
                         excluded_tasks=excluded_tasks,
                         enable_prefetch=False)
                         
        # Streams
        [%for (s in w.streams) { %]
        self.[%=s.name.ftlc()%]: [%=s.pyType()%] = None
        [%}%]

        # Tasks
        [%for (t in w.tasks) {%]
        [%if (t.isPyTask()) {%]
        self.[%=t.name.ftlc()%] = None
        [%}%]
        [%}%]
        
        # Task creation
        self.tasks = []
        [%for (t in w.getPyTasks()){%]
        if [%=w.name%]Tasks.[%=t.name.toSnakeCaseUpper()%] not in self._excluded_tasks:
            self.[%=t.name.ftlc()%] = [%=t.name%]()
            self.[%=t.name.ftlc()%].workflow = self
            self.tasks.append(self.[%=t.name.ftlc()%])
        [%}%]

    def excluded_tasks(self, tasks=[]):
        assert isinstance(tasks, list)
        assert not tasks or [t for t in tasks if isinstance(t, [%=w.name%]Tasks)]
        self._excluded_tasks = tasks

    def createWorker(self):
        worker = [%=w.name%](Mode.WORKER)
        worker.instance(self._instance)
        return worker

    [%for (p in w.parameters) { %]
    def set[%=p.name.ftuc()%](self, [%=p.name%]):
        self.[%=p.name%] = [%=p.name%]

    def get[%=p.name.ftuc()%](self):
        return self.[%=p.name%]
        
    [%}%]

    """
     * Run with initial delay in ms before starting execution (after creating broker
     * if master)
     * 
     * @param delay
    """
    def run(self, delay=0):
        """Run with an initial delay before starting execution

        :param delay: delay in ms before this worker will start running. Defaults to 0
        :type delay: int
        """
        self._delay=delay

        try:
            time.sleep(delay)
            self.connect()
            
            # Initialise Streams
            [%for (s in w.streams) {%]
            [%=s.genInitStream()%]
            
            [%}
            
            if (not w.getPyTasks().isEmpty()) {%]
            if (self.is_worker()):
            	[%for (t in w.getPyTasks()){%]
                if not [%=w.name%]Tasks.[%=t.name.toSnakeCaseUpper()%] in self._excluded_tasks:
                    [%=t.setup()%]
            	[%}
            }%]
        except Exception as ex:
            self.local_logger.exception("")
            self.report_internal_exception(ex)

    [%for (s in w.streams) { %]
    def get[%=s.name%](self) -> [%=s.pyType()%]:
        return self.[%=s.name.ftlc()%]
        
    [%}%]
    [%for (t in w.tasks) {%]
    def get[%=t.name%](self):
        return self.[%=t.name.ftlc()%]
        
    [%}%]
    def _create_serializer(self) -> Serializer:
        return [%=w.getSerializer().~implClass%]()

    def _register_custom_serialization_types(self):
    [%for (t in w.types) {%]
        self._serializer.register_type([%=t.name.toSnakeCaseLower()%].[%=t.name%])
        [%for (e in t.fields.select(e|e.isTypeOf(CrossflowLanguageModel!EnumField))) {%]
        self._serializer.register_type([%=t.name.toSnakeCaseLower()%].[%=e.name.ftuc()%])
        [%}%]
    [%}%]


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-name', default='[%=w.name%]Python', help='The name of the workflow')
    parser.add_argument('-brokerHost', default='localhost', help='Host of the JMX broker')
    parser.add_argument('-stompPort', default=61613, help='Port to use for stomp based messages')
    parser.add_argument('-instance', default=None, help='The instance of the master (to contribute to)')
    parser.add_argument('-mode', default='WORKER', help='must be one of WORKER or API')
    
    parsedArgs = parser.parse_args(sys.argv[1:len(sys.argv)])
    
    app = [%=w.name%](name=parsedArgs.name,
                      instance=parsedArgs.instance,
                      broker_host=parsedArgs.brokerHost,
                      stomp_port=parsedArgs.stompPort,
                      mode=Mode.enum_from_name(parsedArgs.mode))
                      
    app.run()

    while (not app.terminated):
        time.sleep(0.1)
    print("terminated")
    
[%
@template
operation Task setup() {%]
    [%for (i in self.input) { %]
    self.[%=i.name.ftlc()%].add_consumer(self.[%=self.name.ftlc()%], "[%=self.name%]");            
    [%}%]
    [%for (o in self.output) { %]
    self.[%=self.name.ftlc()%].set[%=o.name%](self.[%=o.name.ftlc%]);
    [%}%]
[%}

@template
operation Stream genInitStream() {
	if (self.inputOf.isEmpty()) {%]
self.[%=self.name.ftlc()%] = BuiltinStream("[%=self.name%]", self[%if (self.isTypeOf(Topic)) {%], True[%}%])
self.[%=self.name.ftlc()%].init()
	[%} else {%]
self.[%=self.name.ftlc()%] = [%=self.name%](self, self._enable_prefetch)
	[%}%]
self._active_streams.append(self.[%=self.name.ftlc()%])
[%}%]