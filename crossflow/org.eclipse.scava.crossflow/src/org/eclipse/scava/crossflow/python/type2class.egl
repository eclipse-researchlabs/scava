[%import "../util.eol";
import "pythonUtil.eol";

// Annotate fields with Python equivalent types
t.~fields = new Sequence();
t.~fields.addAll(t.fields);
t.~fields.addAll(t.closure(e|e.extending).fields.flatten);
for (f in t.~fields) {
	// Normal DataField
    if (f.isTypeOf(CrossflowLanguageModel!DataField)) {
        f.~defaultValue = "None";
        switch (f.type) {
        
        // Strings and Chars
        case "Character":
        	continue;
        case "char":
        	continue;
        case "String":
        	continue;
        case "string":
            f.~pyType = "str";
        
        // Numeric Types other than Float
        case "Double":
        	continue;
        case "double":
        	continue;
        case "Long":
        	continue;
        case "long":
        	continue;
        case "Integer":
        	continue;
        case "int":
            f.~pyType = "int";
        
        // Floats
        case "Float":
        	continue;
        case "float":
            f.~pyType = "float";
        
        // Boolean
        case "Boolean":
            continue;
        case "boolean":
            f.~pyType = "bool";
            
        // Default
        default:
            f.~pyType = f.name.ftuc();
        }
    } 
    // EnumField
    else {
        f.~pyType = f.name.ftuc();
    }
}

// Import generation
if (t.fields.exists(f|f.isTypeOf(CrossflowLanguageModel!EnumField))) {%]
from enum import Enum, unique
[%}%]
from typing import Union


[%if (t.isJob()) {%]
from crossflow.runtime import Job
[%}

if (t.extending.isDefined()) {%]
from crossflow.[%=package%].[%=t.extending.name.toSnakeCaseLower()%] import [%=t.extending.name%]
[%}%]


[% 
// Generate enum types - generate before main type for typehinting support
for (f in t.fields.select(f|f.isTypeOf(CrossflowLanguageModel!EnumField))) {%]
@unique
class [%=f.name.ftuc()%](Enum):
    """NOTE: Auto-generated by [%=genRule%][%if (genDate.isDefined()) {%] on [%=genDate%][%}%]

    Do not edit this class manually
    """

    [% for (e in f.values) {%]
    [%=e.toSnakeCaseUpper()%] = "[%=e%]"
    [%}%]


[%}%]
class [%=t.name%][%if (t.getSuperType().isDefined()) {%]([%=t.getSuperType()%])[%}%]:
    """NOTE: Auto-generated by [%=genRule%][%if (genDate.isDefined()) {%] on [%=genDate%][%}%]

    Do not edit this class manually
    """

    [% if (not t.~fields.isEmpty() or t.isJob()) {%]
    def __init__(self,
        [% for (f in t.~fields) {%]
        [%=f.name.toSnakeCaseLower()%]: [%=f.~pyType%] = [% if (f.many) {%][][%} else {%]None[%}%],
        [%}
        if (t.isJob()) {%]
        correlation_id: Union["[%=t.name%]", Job, str] = None
        [%}
        %]
    ):
        super().__init__([% if (t.isJob()) {%]correlation_id=correlation_id[%}%])
        [% for (f in t.~fields) {%]
        self._[%=f.name.toSnakeCaseLower()%] = [%=f.name.toSnakeCaseLower()%]
        [%}
    }%]

    [%for (f in t.fields) { %]
    @property
    def [%=f.name.toSnakeCaseLower()%](self) -> [%=f.~pyType%]:
        return self._[%=f.name.toSnakeCaseLower()%]

    @[%=f.name.toSnakeCaseLower()%].setter
    def [%=f.name.toSnakeCaseLower()%](self, [%=f.name.toSnakeCaseLower()%]: [%=f.~pyType%]):
        self._[%=f.name.toSnakeCaseLower()%] = [%=f.name.toSnakeCaseLower()%]

    [%}%]
    def __str__(self):
        [%
        var names = t.fields.collect(f|f.name.toSnakeCaseLower());
        if (t.isJob()) {
        	// TODO: Replace this with snakecased names when runtime changes
            names.add("job_id");
            names.add("correlation_id");
            names.add("destination");
        }
        var format = "";
        for (n in names) {
        	format += n + "={self." + n + "}";
        	if (hasMore) format += ", ";
        }
        %]
        return f"[%=t.name%] ( [%=format%] )"
[%
operation Type getSuperType() : String {
    if (self.isJob()) {
        if (self.extending.isUndefined()) return "Job";
        else return self.extending.name;
    }
    return null;
}

operation Field getPythonInitialiser() {
    if (self.many) {
        return "[]";
    }
    else {
        if (self.type == 'byte') return '0';
        if (self.type == 'int') return '0';
        if (self.type == 'long') return '0';
        if (self.type == 'float') return '0.0';
        if (self.type == 'double') return '0.0';
        if (self.type == 'boolean') return 'False';
        return '""';
    }
}%]