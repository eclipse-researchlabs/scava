[%import "../util.eol";
import "pythonUtil.eol";%]
import logging
import multiprocessing
import time
from abc import abstractmethod
from typing import Dict

from crossflow.runtime import FailedJob, Task
from crossflow.[%=package%].[%=w.name.toSnakeCaseLower()%]_tasks import [%=w.name%]Tasks

[% // Combine imports for in and out
var types = t.input.collect(s|s.type).asSet();
types.addAll(t.output.collect(s|s.type));
for (i in types) {%]
from crossflow.[%=package%].[%=i.name.toSnakeCaseLower()%] import [%=i.name%]
[%}%]
[% // Combine Streams
var streams = t.input.asSet();
streams.addAll(t.output);
for (i in streams) {%]
from crossflow.[%=package%].[%=i.name.toSnakeCaseLower()%] import [%=i.name%]
[%}%]


class [%=t.name%]Base(Task):
    """NOTE: Auto-generated by [%=genRule%][%if (genDate.isDefined()) {%] on [%=genDate%][%}%]
    
    Do not edit this class manually
    """
    
    task_enum: [%=w.name%]Tasks = [%=w.name%]Tasks.[%=t.name.toSnakeCaseUpper()%]

    def __init__(self):
        super().__init__()
                
        # Streams        
        [%for (s in t.output) { %]
        self._[%=s.name.toSnakeCaseLower()%]: [%=s.name%] = None
        [%}%]


    @property
    def name(self) -> str:
        return self.__class__.task_enum.value

    [%if (t.isTypeOf(Source)) {%]
    def _pre_send(self, job: Job) -> Job:
        job = super()._pre_send(job)
        job.transactional = False
        return job
        
    [%}
    
    // Handle Output Streams
    for (s in t.output) { %]
    @property
    def [%=s.name.toSnakeCaseLower()%](self) -> [%=s.name%]:
        return self._[%=s.name.toSnakeCaseLower()%]
    
    @[%=s.name.toSnakeCaseLower()%].setter
    def [%=s.name.toSnakeCaseLower()%](self, stream: [%=s.name%]):
        self._[%=s.name.toSnakeCaseLower()%] = stream
        self._sent["[%=s.name.toSnakeCaseLower()%]"] = False

    def send_to_[%=s.name.toSnakeCaseLower()%](self, job: [%=s.type.name%]):
        self._pre_send(job)
        self.[%=s.name.toSnakeCaseLower()%].send(job, self.name)
        self._sent["[%=s.name.toSnakeCaseLower()%]"] = True
    
    def _send_confirmation_to_[%=s.name.toSnakeCaseLower()%](self):
        if self._sent.get("[%=s.name.toSnakeCaseLower()%]", False):
            conf = [%=s.type.name%]()
            conf.correlation_id = self.active_job.job_id
            conf.is_transaction_success_message = True
            conf.total_outputs = self.total_outputs
            self.[%=s.name.toSnakeCaseLower()%].send(conf, self.name)
        
    [%}%]
    [%for (s in t.input) { %]
    def consume_[%=s.name.toSnakeCaseLower()%]_with_notifications(self, input_job: [%=s.type.name%]):
        print(f"Received {input_job}")
        
        try:
            self.active_job = input_job
            
            # Delegate function to perform actual processing and confirmation messaging
            def delegate():
                self.workflow.set_task_in_progress(self, input_job.job_id)
                [%if (t.isSingleOut()) {%]
                result = self.consume_[%=s.name.toSnakeCaseLower()%](self.active_job)
                if result is not None:
                    result.transactional = False
                    self.send_to_[%=t.output.first.name.toSnakeCaseLower()%](result)
                [%}else {%]
                self.consume_[%=s.name.toSnakeCaseLower()%](self.active_job)
                    [%for (o in t.output) {%]
                self._send_confirmation_to_[%=o.name.toSnakeCaseLower()%]()
                    [%}
                }%]
            
            # Start execution in a separate process
            process = multiprocessing.Process(target=delegate)
            process.start()
            
            # Calculate the timeout searching in order of input_job, default set in task, and finally setting to no timeout            
            if self.active_job.timeout > 0:
                timeout = self.active_job.timeout
            elif self.timeout > 0:
                timeout = self.timeout
            else:
                timeout = 0             
            
            # Loop
            time_left = timeout
            while process.exitcode is None:
                # Check if a cancel signal was received for the current job
                if self._cancel_pending:
                    process.terminate()
                    raise Exception(f"{self.active_job.job_id} cancelled")
                
                # Check timeout has not been reached
                if timeout > 0 and time_left <= 0:
                    process.terminate()
                    raise TimeoutError(f"{self.active_job.job_id} timed out after {timeout}")
                
                time.sleep(1)
                time_left -= 1

        # Timeout reached
        except TimeoutError as ex:
            try:
                self.workflow.report_internal_exception(ex)
                send = self.on_consume_[%=s.name.toSnakeCaseLower()%]_timeout(self.active_job)
                if send:
                    self.active_job.failures += 1
                    self.workflow.failed_jobs_topic.send(FailedJob.from_exception(self.active_job, ex, self))
            except:
                self.workflow.report_internal_exception(ex)

        # All other exceptions  
        except Exception as ex:
            try:
                self.workflow.report_internal_exception(ex)
                self.active_job.failures += 1
                self.workflow.failed_jobs_topic.send(FailedJob.from_exception(self.active_job, ex, self))
            except:
                self.workflow.report_internal_exception(ex)

        # Cleanup
        finally:
            try:
                self.workflow.set_task_waiting(self)
                self.active_job = None
                self._cancel_pending = False
                self._sent.update((k, False) for k in self._sent)                
            except Exception as ex:
                self.workflow.local_logger.exception("")
                self.workflow.report_internal_exception(ex)

    @abstractmethod
    def consume_[%=s.name.toSnakeCaseLower()%](self, input_job: [%=s.type.name%]):
        pass
    
    def on_consume_[%=s.name.toSnakeCaseLower()%]_timeout(self, input_job: [%=s.type.name%]):
        return True
        
    def on_consume_[%=s.name.toSnakeCaseLower()%]_cancelled(self, input_job: [%=s.type.name%]):
        return True
        
    [%}
    
    if (t.isKindOf(Source)){%]
    def produce(self):
        pass
        
    [%}%]
    def close(self):
        pass
