[%import "../util.eol";
import "pythonUtil.eol";%]
import multiprocessing
import time

from crossflow.runtime import FailedJob, Task
from crossflow.[%=package%].[%=w.pyVarName()%]_tasks import [%=w.name%]Tasks

[% for (t in outputTypes) { %]
from crossflow.[%=package%].[%=t.name.toSnakeCaseLower()%] import [%=t.name%]
[%}%]


class [%=t.name%]Base(Task):
    """NOTE: Auto-generated by [%=genRule%][%if (genDate.isDefined()) {%] on [%=genDate%][%}%]
    
    Do not edit this class manually
    """
    
    task_enum: [%=w.name%]Tasks = [%=w.name%]Tasks.[%=t.name.toSnakeCaseUpper()%]

    def __init__(self):
        super().__init__()
        
        # Streams
        [%for (s in t.output) { %]
        self.[%=s.name.ftlc()%] = None
        self._has_sent_to_[%=s.pyVarName()%] = False
        
        [%}%]

    @property
    def name(self) -> str:
        return self.__class__.task_enum.value

    def get_total_outputs(self):
        return sum([[%
        for (s in t.output) {
            out.print("self._has_sent_to_" + s.pyVarName());
            if (hasMore) {
                out.print(", ");
            }
        }%]])
    
    [%for (o in t.output) { %]
    def set[%=o.name%](self, [%=o.name.ftlc()%]):
        self.[%=o.name.ftlc()%] = [%=o.name.ftlc()%]
    
    def get[%=o.name%](self):
        return self.[%=o.name.ftlc()%]
    
    def sendTo[%=o.name%](self, [%=o.type.name.ftlc()%]):
        [%=o.type.name.ftlc()%].setCacheable(self.cacheable)
        [%if(t.isTypeOf(Source)){%]
        [%=o.type.name.ftlc()%].setTransactional(False)
        [%}%]
        self.get[%=o.name%]().send([%=o.type.name.ftlc()%][%if(not o.inputOf.isEmpty()){%], self.__class__.__name__[%}%])
    
    [%}%]
    [%for (s in t.input) { %]
    def consume[%=s.name%]WithNotifications(self, [%=s.type.name.ftlc()%]):
        [%for (o in t.output) {%]
        self._has_sent_to_[%=o.pyVarName()%] = False
        [%}%]
        
        try:
            def consumer():
                self.workflow.set_task_in_progress(self, [%=s.type.name.ftlc()%].getId())
            [%if (t.isSingleOut()) {%]
                result = self.consume[%=s.name%]([%=s.type.name.ftlc()%])
                if result is not None:
                    if self.cacheable:
                        result.setCorrelationId([%=s.type.name.ftlc()%].getId())
                    result.setTransactional(False)
                    self.sendTo[%=t.output.first.name%](result)
            [%}else {%]
                self.consume[%=s.name%]([%=s.type.name.ftlc()%])
                
                [%for (o in t.output) {
                    var conf = o.pyVarName() + "_conf";%]
                [%=conf%] = [%=t.output.first.type.name%]()
                [%=conf%].setCorrelationId([%=s.type.name.ftlc()%].getId())
                [%=conf%].setIsTransactionSuccessMessage(True)
                [%=conf%].totalOutputs = self.get_total_outputs()
                if self._has_sent_to_[%=o.pyVarName()%]:
                    self.sendTo[%=o.name%]([%=conf%])
                    
                [%}
            }%]
            
            timeout = int([%=s.type.name.ftlc()%].timeout) if int([%=s.type.name.ftlc()%].timeout) > 0 else int(self.timeout)
            
            if timeout > 0:
                process = multiprocessing.Process(target=consumer)
                process.start()
                process.join(timeout)
                if process.is_alive():
                    process.terminate()
                    raise TimeoutError
            else:
                consumer()
            
        except Exception as ex:
            self.workflow.local_logger.exception("")
            try:
                send_failed = True
                if ex.__class__ == TimeoutError:
                    send_failed = self.on_consume_[%=s.pyVarName()%]_timeout([%=s.type.name.ftlc()%])
                
                if send_failed:
                    [%=s.type.name.ftlc()%].setFailures(int([%=s.type.name.ftlc()%].getFailures()) + 1)
                    self.workflow.failed_jobs_topic.send(FailedJob.from_exception([%=s.type.name.ftlc()%], ex, self))
            
            except Exception as ex:
                self.workflow.local_logger.exception("")
                self.workflow.report_internal_exception(ex)
        
        finally:
            try:
                self.workflow.set_task_waiting(self)
            except Exception as ex:
                self.workflow.local_logger.exception("")
                self.workflow.report_internal_exception(ex)
    
    def consume[%=s.name%](self, [%=s.type.name.ftlc()%]):
        pass
    
    def on_consume_[%=s.pyVarName()%]_timeout(self, [%=s.type.pyVarName()%]):
        return True
    [%}%]
    
    [%if (t.isKindOf(Source)){%]
    def produce(self):
        pass
        
    [%}%]
    def close(self):
        pass
