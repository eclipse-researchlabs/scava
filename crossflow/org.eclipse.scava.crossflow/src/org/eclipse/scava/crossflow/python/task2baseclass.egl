[%import "../util.eol";
import "pythonUtil.eol";%]
from concurrent.futures import Future
from concurrent.futures.thread import ThreadPoolExecutor
import time

from crossflow.runtime import FailedJob, Task
from crossflow.[%=package%].[%=w.name.toSnakeCaseLower()%]_tasks import [%=w.name%]Tasks

[% for (i in t.input.collect(s|s.type).asSet()) {%]
from crossflow.[%=package%].[%=i.name.toSnakeCaseLower()%] import [%=i.name%]
[%}%]
[% for (i in t.output.collect(s|s.type).asSet()) { %]
from crossflow.[%=package%].[%=i.name.toSnakeCaseLower()%] import [%=i.name%]
[%}%]


class [%=t.name%]Base(Task):
    """NOTE: Auto-generated by [%=genRule%][%if (genDate.isDefined()) {%] on [%=genDate%][%}%]
    
    Do not edit this class manually
    """
    
    task_enum: [%=w.name%]Tasks = [%=w.name%]Tasks.[%=t.name.toSnakeCaseUpper()%]

    def __init__(self):
        super().__init__()
        
        self._current_future: Future = None
        
        # Streams
        [%for (s in t.output) { %]
        self.[%=s.name.ftlc()%] = None
        self._has_sent_to_[%=s.name.toSnakeCaseLower()%] = False
        
        [%}%]

    @property
    def name(self) -> str:
        return self.__class__.task_enum.value

    @property
    def total_outputs(self) -> int:
        return sum([[%
        for (s in t.output) {
            out.print("self._has_sent_to_" + s.name.toSnakeCaseLower());
            if (hasMore) {
                out.print(", ");
            }
        }%]])
    
    [%for (o in t.output) { %]
    def set[%=o.name%](self, [%=o.name.ftlc()%]):
        self.[%=o.name.ftlc()%] = [%=o.name.ftlc()%]
    
    def get[%=o.name%](self):
        return self.[%=o.name.ftlc()%]
    
    def sendTo[%=o.name%](self, [%=o.type.name.ftlc()%]):
        [%=o.type.name.ftlc()%]._current_root_ids = self._current_root_ids
        [%=o.type.name.ftlc()%].cacheable = self.cacheable
        [%if(t.isTypeOf(Source)){%]
        [%=o.type.name.ftlc()%].transactional = False
        [%}%]
        self.get[%=o.name%]().send([%=o.type.name.ftlc()%][%if(not o.inputOf.isEmpty()){%], self.__class__.__name__[%}%])
    
    [%}%]
    [%for (s in t.input) { %]
    def consume[%=s.name%]WithNotifications(self, [%=s.type.name.ftlc()%]: [%=s.type.name%]):
        [%for (o in t.output) {%]
        self._has_sent_to_[%=o.name.toSnakeCaseLower()%] = False
        [%}%]
        
        try:
            self._current_job_id = [%=s.type.name.ftlc()%].job_id
            self._current_root_ids = [%=s.type.name.ftlc()%].root_ids if [%=s.type.name.ftlc()%].root_ids else [%=s.type.name.ftlc()%].job_id
            self.workflow.set_task_in_progress(self, [%=s.type.name.ftlc()%].job_id)
            def consume():
            [%if (t.isSingleOut()) {%]
                result = self.consume[%=s.name%]([%=s.type.name.ftlc()%])
                if result is not None:
                    if self.cacheable:
                        result.correlation_id = [%=s.type.name.ftlc()%].job_id
                    result.transactional = False
                    self.sendTo[%=t.output.first.name%](result)
            [%}else {%]
                self.consume[%=s.name%]([%=s.type.name.ftlc()%])
                
                [%for (o in t.output) {
                    var confirmation = o.name.toSnakeCaseLower() + "_confirmation";%]
                [%=confirmation%] = [%=t.output.first.type.name%]()
                [%=confirmation%].correlation_id = [%=s.type.name.ftlc()%].job_id
                [%=confirmation%].is_transaction_success_message = True
                [%=confirmation%].total_outputs = self.total_outputs
                if self._has_sent_to_[%=o.name.toSnakeCaseLower()%]:
                    self.sendTo[%=o.name%]([%=confirmation%])
                    
                [%}
            }%]

            with ThreadPoolExecutor(max_workers=1) as executor:
                self._current_future = executor.submit(consume)
                
            timeout = [%=s.type.name.ftlc()%].timeout if int([%=s.type.name.ftlc()%].timeout) > 0 else self._timeout
            self._current_future.result(timeout if timeout > 0 else None)

        # Timeout reached
        except TimeoutError as ex:
            try:
                self.workflow.report_internal_exception(ex)
                send = self.on_consume_[%=s.name.toSnakeCaseLower()%]_timeout([%=s.type.name.ftlc()%])
                if send:
                    [%=s.type.name.ftlc()%].failures = [%=s.type.name.ftlc()%].failures + 1
                    self.workflow.failed_jobs_topic.send(FailedJob.from_exception([%=s.type.name.ftlc()%], ex, self))
            except:
                self.workflow.report_internal_exception(ex)

        # All other exceptions  
        except Exception as ex:
            try:
                self.workflow.report_internal_exception(ex)
                self.workflow.failed_jobs_topic.send(FailedJob.from_exception([%=s.type.name.ftlc()%], ex, self))
            except:
                self.workflow.report_internal_exception(ex)

        # Cleanup
        finally:
            try:
                self.workflow.set_task_waiting(self)
                self._current_job_id = None
                self._current_root_ids = None
                self._current_future = None
            except Exception as ex:
                self.workflow.local_logger.exception("")
                self.workflow.report_internal_exception(ex)

    def consume[%=s.name%](self, [%=s.type.name.ftlc()%]):
        pass
    
    def on_consume_[%=s.name.toSnakeCaseLower()%]_timeout(self, [%=s.type.name.toSnakeCaseLower()%]):
        return True
    [%}%]
    
    [%if (t.isKindOf(Source)){%]
    def produce(self):
        pass
        
    [%}%]
    def close(self):
        pass
