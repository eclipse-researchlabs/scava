[%import "../util.eol";

var hasParameters = not t.parameters.isEmpty();
var hasOutputs = not t.output.isEmpty();
%]
/** This class was automatically generated and should not be modified */
package [%=package%];

import java.util.HashMap;
import java.util.concurrent.TimeUnit;

import javax.annotation.Generated;

import org.eclipse.scava.crossflow.runtime.BuiltinStream;
import org.eclipse.scava.crossflow.runtime.FailedJob;
import org.eclipse.scava.crossflow.runtime.Task;

import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
[%
for(i in imports){%]
import [%=i%].*;
[%}%]

@Generated(value = "org.eclipse.scava.crossflow.java.[%=genRule%]"[% if (genDate.isDefined()) { %], date = "[%=genDate%]"[%}%])
public abstract class [%=t.name%]Base extends Task [%if(t.input.notEmpty()){%] implements [%=t.input.collect(s|s.name + "Consumer").concat(",")%][%}%]{

	/**
	 * Enum Identifier of this Task
	 */
	public static final [%=w.name%]Tasks TASK = [%=w.name%]Tasks.[%=t.name.toSnakeCaseUpper()%]; 
	
	protected [%=w.name%] workflow;
	protected long timeout = 0;
	
	[%// Task parameters
	// TODO: Handle many attirbute of fields
	if (hasParameters) {%]
	// Parameters
		[%for (p in t.parameters) {%]
	protected [%=p.type%] [%=p.name%];
		[%}%]

	[%}
	
	// Output streams
	if (hasOutputs) {%]
	// Output Streams
		[%for (o in t.output) {
			var type;		
			if(o.inputOf.isEmpty()){
				type = "BuiltinStream<" + o.type.name + ">";
			} else {
				type = o.name;
			}%]	
	protected [%=type%] [%=o.name.ftlc()%];	
			[%}
		
		if (not t.isSingleOut()) { %]
		
	// Output Sent Flags
			[%for (o in t.output) {%]
	boolean hasSentTo[%=o.name%] = false;
			[%}
		}
	}
	
	%]
	protected HashMap<String,ListenableFuture<?>> currentRunnables= new HashMap();
	[%
	
	// Configuration streams if applicable
	var configStreams = t.input.select(s|s.isConfigurationChannel());
	if (not configStreams.isEmpty()) {%]
	// Configuration Received Flags
		[%for (i in t.input.select(s|s.isConfigurationChannel())) {%]
	boolean hasProcessed[%=i.name%] = false;
		[%}%]

	[%}
	
	// General methods
	%]
	public void setWorkflow([%=w.name%] workflow) {
		this.workflow = workflow;
	}

	public [%=w.name%] getWorkflow() {
		return workflow;
	}
	
	@Override
	public String getName() {
		return TASK.getTaskName();
	}

	public [%=w.name%]Tasks getTaskEnum() {
		return TASK;
	}
	
	public long getTimeout() {
		return timeout;
	}
	
	public void setTimeout(long timeout) {
		this.timeout = timeout;
	}

	[% // Parameter getters and setters
	if (hasParameters) {%]
		[%for (p in t.parameters) {%]
	public [%=p.type%] get[%=p.name.ftuc()%]() {
		return [%=p.name%];
	}

	public void set[%=p.name.ftuc()%]([%=p.type%] [%=p.name%]) {
		this.[%=p.name%] = [%=p.name%];
	}

		[%}
	}
	
	// Output stream methods
	if (hasOutputs) {%]
		[%for (o in t.output) { 
			var type;		
			if(o.inputOf.isEmpty()){
				type = "BuiltinStream<" + o.type.name + ">";
			} else {
				type = o.name;
			}		
		%]		
	protected void set[%=o.name%]([%=type%] [%=o.name.ftlc()%]) {
		this.[%=o.name.ftlc()%] = [%=o.name.ftlc()%];
	}

	protected [%=type%] get[%=o.name%]() {
		return [%=o.name.ftlc()%];
	}

	public void sendTo[%=o.name%]([%=o.type.name%] [%=o.type.name.ftlc()%]) [%if(o.inputOf.isEmpty()){%]throws Exception [%}%]{
		[%=o.type.name.ftlc()%].setCacheable(this.cacheable);
			[%if(t.isTypeOf(CrossflowLanguageModel!Source)){%]
		[%=o.type.name.ftlc()%].setTransactional(false);
			[%}%]
			[%if(t.multipleOutputs or not (t.output.size==1)) {%]
		hasSentTo[%=o.name%] = true;
			[%}%]
		get[%=o.name%]().send([%=o.type.name.ftlc()%][%if(not o.inputOf.isEmpty()){%], TASK.getTaskName()[%}%]);
	}

		[%}
	}
	
	// If task is a source, needs a produce method
	if (t.isKindOf(CrossflowLanguageModel!Source)){%]
	public abstract void produce() throws Exception;
	
	[%}
	
	// Helper for calculate totalOutputs
	if (hasOutputs and not t.isSingleOut()) {%]
	public int getTotalOutputs() {
		return [%
		for (s in t.output) {
			out.print("(hasSentTo");
			out.print(s.name);
			out.print(" ? 1 : 0)");
			if (hasMore) {
				out.print("	+ ");
			} else {
				out.println(";");
			}
		}%]
	}
	
	[%}
	
	for (s in t.input) { %]
	[%=s.createStartOfConsumeMethod()%]
		[%if (not s.isConfigurationChannel() and t.isSingleOut()) {%]
				[%=t.output.first.type.name%] result = consume[%=s.name%]([%=s.type.name.ftlc()%]);
				if(result != null){
					if(isCacheable())
						result.setCorrelationId([%=s.type.name.ftlc()%].getJobId());				
					result.setTransactional(false);
					sendTo[%=t.output.first.name%](result);
				}
		[%}else {%]
		
				// Perform the actual processing
				consume[%=s.name%]([%=s.type.name.ftlc()%]);
				
			[%if(not s.isConfigurationChannel()){%]
				[%=s.sendConfirmationMessage()%]
			[%}
		}%]
	[%=s.createEndOfConsumeMethod()%]
	[%}%]
	
	public boolean cancelJob(String id) {
		if (currentRunnables.containsKey(id)) {
			boolean ret = currentRunnables.get(id).cancel(true);
			currentRunnables.remove(id);
			return ret;
		}
		return false;
	}
		
}

[%
@template
operation CrossflowLanguageModel!Stream createStartOfConsumeMethod() {%]
@Override
public void consume[%=self.name%]WithNotifications([%=self.type.name%] [%=self.type.name.ftlc()%]) {
	[%if (t.hasConfiguration() and not self.isConfigurationChannel()){ %]
	// Await configuration to be processed
	while([%
	for (s in t.input) {
		if(s.isConfigurationChannel()){
			%]!hasProcessed[%=s.name%] ||[%
		}
	}
	out.chop(3);
	%]) {
		try {
			Thread.sleep(100);
		} catch (InterruptedException e) {
			workflow.reportInternalException(e);
		}
	}
		
	[%}
	
	if (not (self.isConfigurationChannel() or t.isSource() or t.isSink())) {%]
	try {
		workflow.get[%=t.name%]s().getSemaphore().acquire();
	} catch (Exception e) {
		workflow.reportInternalException(e);
	}
	
	[% if (not t.isSingleOut()) {
	// Reset output sent flags
		for (ss in t.output) { %]
	hasSentTo[%=ss.name%] = false;
		[%}
		
	}%]
	Runnable consumer = () -> {		
	[%}%]
		try {
			workflow.setTaskInProgess(this);
[%}

@template
operation CrossflowLanguageModel!Stream createEndOfConsumeMethod() {%]

		} catch (Throwable ex) {
			try {
				boolean sendFailed = true;
				if (ex instanceof InterruptedException) {
					sendFailed = onConsume[%=self.name%]Timeout([%=self.type.name.ftlc()%]);
				}
				if (sendFailed) {
					[%=self.type.name.ftlc()%].setFailures([%=self.type.name.ftlc()%].getFailures()+1);
					workflow.getFailedJobsTopic().send(new FailedJob([%=self.type.name.ftlc()%], new Exception(ex), this));
				}
			} catch (Exception e) {
				workflow.reportInternalException(e);
			}
		} finally {
			try {
				[%if (not (self.isConfigurationChannel() or t.isKindOf(CrossflowLanguageModel!Source) or t.isKindOf(CrossflowLanguageModel!Sink))){%]
				workflow.get[%=t.name%]s().getSemaphore().release();
				[%}if(self.isConfigurationChannel()){%]
				hasProcessed[%=self.name%] = true;
				[%}%]
				workflow.setTaskWaiting(this);
				
				//after job finishes clear the current job
				currentRunnables.remove([%=self.type.name.ftlc()%].getJobId());
			} catch (Exception e) {
				workflow.reportInternalException(e);
			}
		}
	[%if (not (self.isConfigurationChannel() or t.isSource() or t.isSink())) {%]		
	};
	
	ListenableFuture<?> consumerFuture = workflow.get[%=t.name%]s().getExecutor().submit(consumer);
	long timeout = [%=self.type.name.ftlc()%].getTimeout() > 0 ? [%=self.type.name.ftlc()%].getTimeout() : this.timeout;
	
	//track current job execution (for cancellation)
	currentRunnables.put([%=self.type.name.ftlc()%].getJobId(),consumerFuture);	
	
	if (timeout > 0) {
		Futures.withTimeout(consumerFuture, [%=self.type.name.ftlc()%].getTimeout(), TimeUnit.SECONDS, workflow.getTimeoutManager());
	}

	[%}%]
}

/**
 * Cleanup callback in the event of a timeout.
 *
 * If this method returns {@code true} then a failed job will be registered by
 * crossflow
 *
 * @param [%=self.type.name.ftlc()%] original input
 * @return {@code true} if a failed job should be registered, {@code false}
 * otherwise.
 */
public boolean onConsume[%=self.name%]Timeout([%=self.type.name%] [%=self.type.name.ftlc()%]) throws Exception {
	return true;
}
	
	[%if(self.isConfigurationChannel() or (t.multipleOutputs or t.output.size<>1)) {%]
public abstract void consume[%=self.name%]([%=self.type.name%] [%=self.type.name.ftlc()%]) throws Exception;

	[%}else {%]
public abstract [%=t.output.first.type.name%] consume[%=self.name%]([%=self.type.name%] [%=self.type.name.ftlc()%]) throws Exception;

	[%}
}

@template
operation CrossflowLanguageModel!Stream sendConfirmationMessage() {
	if(not t.isSingleOut()) {
		for (s in t.output) { %]
// Send confirmation to [%=s.name%]
[%=s.type.name%] confirmation[%=s.name%] = new [%=s.type.name%]();
confirmation[%=s.name%].setCorrelationId([%=self.type.name.ftlc()%].getJobId());
confirmation[%=s.name%].setIsTransactionSuccessMessage(true);
confirmation[%=s.name%].setTotalOutputs(getTotalOutputs());
if (hasSentTo[%=s.name%]) {
	sendTo[%=s.name%](confirmation[%=s.name%]);
}

		[%}	
	}	
}%]